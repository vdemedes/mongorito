// Generated by CoffeeScript 1.3.3
var Client, Model, Mongorito, async, extendClass, hasProp, inflect, mongolian;

mongolian = require('mongolian');

async = require('async');

inflect = require('i')();

Client = void 0;

String.prototype.replaceAt = function(index, char) {
  return this.substr(0, index) + char + this.substr(index + char.length);
};

hasProp = {}.hasOwnProperty;

extendClass = function(child, parent) {
  var ctor, key;
  for (key in parent) {
    if (hasProp.call(parent, key)) {
      child[key] = parent[key];
    }
  }
  ctor = function() {
    var newKey;
    this.constructor = child;
    for (key in child.prototype) {
      newKey = inflect.camelize(key);
      this[newKey.replaceAt(0, String.fromCharCode(32 + newKey.charCodeAt(0)))] = child.prototype[key];
    }
    return void 0;
  };
  ctor.prototype = parent.prototype;
  child.prototype = new ctor;
  child.__super__ = parent.prototype;
  return child;
};

Mongorito = (function() {

  function Mongorito() {}

  Mongorito.disconnect = function() {
    return Client.server.close();
  };

  Mongorito.connect = function(servers) {
    if (servers == null) {
      servers = [];
    }
    return Client = new mongolian(servers[0], {
      log: {
        debug: function() {},
        info: function() {},
        warn: function() {},
        error: function() {}
      }
    });
  };

  Mongorito.bake = function(model) {
    extendClass(model, Model);
    model.prototype.collectionName = model.collectionName = model.prototype.collectionName || inflect.pluralize(model.name.toLowerCase());
    if (model.prototype.scopes) {
      Object.keys(model.prototype.scopes).forEach(function(scope) {
        return model[scope] = function(callback) {
          return model.find(model.prototype.scopes[scope], callback);
        };
      });
    }
    model.prototype.keys.forEach(function(key) {
      model.prototype.__defineGetter__(key, function() {
        return this.get(key);
      });
      return model.prototype.__defineSetter__(key, function(value) {
        return this.set(key, value);
      });
    });
    model.prototype.__defineGetter__('_id', function() {
      return this.get('_id');
    });
    model.prototype.__defineSetter__('_id', function(value) {
      return this.set('_id', value.toString());
    });
    model.prototype.model = model.model = model;
    return model;
  };

  return Mongorito;

})();

Model = (function() {

  Model.prototype.fields = {};

  Model.prototype.old = {};

  Model.prototype.get = function(key) {
    return this.fields[key];
  };

  Model.prototype.set = function(key, value) {
    if (this.fields[key]) {
      this.old[key] = this.fields[key];
    }
    return this.fields[key] = value;
  };

  function Model() {
    this.fields = this.old = {};
  }

  Model.prototype.toJSON = function() {
    return this.fields;
  };

  Model.bakeModelsFromItems = function(items) {
    var field, item, model, models, _i, _len;
    models = [];
    for (_i = 0, _len = items.length; _i < _len; _i++) {
      item = items[_i];
      item._id = item._id.toString();
      model = new this.model;
      model.collectionName = this.model.collectionName;
      model.old = {};
      model.model = this.model;
      for (field in item) {
        model[field] = item[field];
      }
      models.push(model);
    }
    return models;
  };

  Model.extractFields = function(options) {
    var fields, notFields, property;
    fields = {};
    notFields = ['limit', 'skip', 'sort'];
    for (property in options) {
      if (options.hasOwnProperty(property) && notFields.indexOf(property) === -1) {
        fields[property] = options[property];
      }
    }
    return fields;
  };

  Model.find = function(options, callback) {
    var query,
      _this = this;
    if (typeof options === 'function') {
      callback = options;
      options = {};
    } else {
      if (options.callback) {
        callback = options.callback;
        delete options.callback;
      }
    }
    if (options._id) {
      return this.findOne(options, callback);
    }
    query = Client.collection(this.collectionName).find(this.extractFields(options));
    if (options.sort) {
      query = query.sort(options.sort);
    }
    if (options.skip) {
      query = query.skip(options.skip);
    }
    if (options.limit) {
      query = query.limit(options.limit);
    }
    return query.toArray(function(err, items) {
      return callback(err, _this.bakeModelsFromItems(items));
    });
  };

  Model.findOne = function(options, callback) {
    var _id,
      _this = this;
    _id = new mongolian.ObjectId(options._id);
    return Client.collection(this.collectionName).find({
      _id: _id
    }).toArray(function(err, items) {
      return callback(err, _this.bakeModelsFromItems(items)[0]);
    });
  };

  Model.prototype.updateAttributes = function(fields) {
    var key, _results;
    if (fields == null) {
      fields = {};
    }
    _results = [];
    for (key in fields) {
      if (-1 < this.keys.indexOf(key)) {
        _results.push(this[key] = fields[key]);
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  Model.prototype.update_attributes = function() {
    return this.updateAttributes.apply(this, arguments);
  };

  Model.prototype.callMethod = function(method) {
    method = this[method] || this[inflect.underscore(method)];
    if (method) {
      return method.call(this);
    }
  };

  Model.prototype.save = function(callback) {
    var _this = this;
    return async.filter(this.keys, function(key, nextKey) {
      var validationMethod;
      validationMethod = _this["validate" + (inflect.camelize(key))] || _this["validate_" + (inflect.underscore(key))];
      if (validationMethod) {
        return validationMethod.call(_this, function(valid) {
          return nextKey(!valid);
        });
      } else {
        return nextKey(false);
      }
    }, function(results) {
      if (results.length > 0) {
        return callback(true, results);
      }
      if (_this.fields._id) {
        return _this.update(callback);
      } else {
        return _this.create(callback);
      }
    });
  };

  Model.prototype.create = function(callback) {
    var _this = this;
    this.callMethod('beforeCreate');
    this.callMethod('aroundCreate');
    return Client.collection(this.collectionName).insert(this.fields, function(err, result) {
      result._id = result._id.toString();
      _this.fields._id = result._id;
      _this.callMethod('aroundCreate');
      _this.callMethod('afterCreate');
      if (callback) {
        return callback(err, result);
      }
    });
  };

  Model.prototype.update = function(callback) {
    var fields, key, _id,
      _this = this;
    fields = {};
    for (key in this.fields) {
      fields[key] = this.fields[key];
    }
    _id = new mongolian.ObjectId(fields._id);
    delete fields._id;
    this.callMethod('beforeUpdate');
    this.callMethod('aroundUpdate');
    return Client.collection(this.collectionName).update({
      _id: _id
    }, fields, function(err, rowsUpdated) {
      _this.callMethod('aroundUpdate');
      _this.callMethod('afterUpdate');
      if (callback) {
        return callback(err, rowsUpdated);
      }
    });
  };

  Model.prototype.remove = function(callback) {
    var _id,
      _this = this;
    _id = new mongolian.ObjectId(this.fields._id);
    this.callMethod('beforeRemove');
    this.callMethod('aroundRemove');
    return Client.collection(this.collectionName).remove({
      _id: _id
    }, function(err) {
      _this.callMethod('aroundRemove');
      _this.callMethod('afterRemove');
      if (callback) {
        return callback(err);
      }
    });
  };

  Model.remove = function(callback) {
    return Client.collection(this.collectionName).remove({}, function(err) {
      if (callback) {
        return callback(err);
      }
    });
  };

  return Model;

})();

module.exports = {
  connect: Mongorito.connect,
  disconnect: Mongorito.disconnect,
  bake: Mongorito.bake
};
